<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RDP远程桌面图像复现</title>
    <url>/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01    原理"></a>0x01    原理</h2><p>　　在使用远程桌面连接服务器时，客户端会将缓存数据保存在当前用户的应用程序数据目录中，这部分数据在会话结束后也不会清除。本文将通过原理分析、数据类型分析，通过手动及自动化的方法对数据拆分合并，再现曾经连过的远程桌面的画面。<span id="more"></span></p>
<h2 id="0x02-手动实现"><a href="#0x02-手动实现" class="headerlink" title="0x02   手动实现"></a>0x02   手动实现</h2><p>　　早期的RDP为了加速连接时的显示，减少数据量的传输，采用了一种技术为<code>BMChache</code>，即位图缓存。<code>BMChache</code>分为两种类型，一种是<code>Bitmap Chaches</code>(位图缓存)，一种是<code>Persisten Bitmap Chaches</code>(持久位图缓存)。区别在于，前一种是临时缓存，与<code>RDP</code>会话生命周期绑定，后一种是持久化的缓存，不受到<code>RDP</code>会话生命周期的限制，即使会话结束后，内容依然会持久化的存在于文件中。</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/%E6%8C%81%E4%B9%85%E4%BD%8D%E5%9B%BE%E7%BC%93%E5%AD%98.png" alt="持久位图缓存"></p>
<p>　　而<code>windows</code>默认是开启持久位图缓存的</p>
<p>　　在<code>Windows XP</code>中，其持<em>久位图</em>缓存文件存储在 ：</p>
<p><font color="red">%USERPROFILE%\Local Settings\Application Data\Microsoft\Terminal Server Client\Cache \</font>路径中</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/winxp%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.png" alt="winxp存放位置"></p>
<p>　　在Windows 7及更高版本系统中，其文件存储在 ：</p>
<p><font color="red">%USERPROFILE%\AppData\Local\Microsoft\Terminal Server Client\Cache\</font>路径中</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/win7%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.png" alt="win7存放位置"></p>
<p>　　而<code>bmc</code>缓存文件数据格式如下：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmc%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6.png" alt="bmc缓存文件"></p>
<p>　　因此手动复现的原理就很简单了，将<code>.bmc/.bin</code>文件按照数据格式拆分出一个完整的位图文件数据，再按照<code>bmp</code>文件格式重组文件头，最终进行组合形成一个完整的<code>bmp</code>位图文件：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmp%E6%96%87%E4%BB%B6%E9%87%8D%E7%BB%84%E6%B5%81%E7%A8%8B.png" alt="bmp文件重组流程"></p>
<p>　　以上述文件<code>bcache24.bmc</code>文件为例，其单个位图数据大小为0x1400，即5120，因此从<code>bmc</code>图像数据中复制5120个字节数据到新文件中，按照<code>bmp</code>文件数据格式重组<code>bmp</code>文件头，形成一个完整的<code>bmp</code>图像：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmp%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt="bmp文件头"></p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/%E5%AE%8C%E6%95%B4bmp%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE.png" alt="完整bmp文件数据"></p>
<p>　　最终成功手动提取出了文件中的缓存图像：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96.png" alt="缓存文件提取"></p>
<h2 id="0x03-自动化工具"><a href="#0x03-自动化工具" class="headerlink" title="0x03   自动化工具"></a>0x03   自动化工具</h2><p>　　一个<code>bmc</code>缓存文件能提取出成百上千个图片文件，因此全部手动提取不太现实，好在已经有前人造好了轮子，首先第一个工具为<code>bmc-tools</code>,它是一个专门解析<code>rdp</code>位图缓存的工具，可对<code>bcache*.bmc和cache????.bin</code>文件进行解析，拆分出其中的位图文件，使用效果如下：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmc-tools%E6%8F%90%E5%8F%96.png" alt="bmc-tools提取"></p>
<p>　　第二个工具为 <code>RdpCacheStitcher</code>，可以使用该图形化工具对原始 <code>RDP</code> 缓存位图进行手动拼接，实现完整的屏幕截图。它提供了一个图形用户拼接的界面和位图存放界面。</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/RdpCacheStitcher.png" alt="RdpCacheStitcher"></p>
<p>　　可以看出，该工具对提取出的所有缓存图像进行了<code>ai</code>算法的识别组合，但是算法不够精准，有些地方是错乱的，因此还需要手动进行调整。</p>
<p>　　第三个工具为<code>BMC Viewer</code>，可以直接对<code>bmc</code>文件进行解析查看，工具会进行<code>ai</code>识图并自动进行拼接，虽然是个一键自动化工具，但是效果显而易见，没有第二个好，但是全局可视化上效果还是不错的。</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/BMC_Viewer.png" alt="BMC_Viewer"></p>
<p>　　这么看来，最终拼的还是<code>ai</code>算法，只要<code>ai</code>算法够精准，完全有可能实现图片拼接，最终还原成一个完整的图像，但是就目前看来，实战中完全够用，真要是还原完整图像的话那应该就是取证方面需要做到的事情了。</p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
  </entry>
  <entry>
    <title>wordpress漏洞-cve-2022-21661-原理及复现</title>
    <url>/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01  原理"></a>0x01  原理</h2><p>　<code>利用条件：① wordpress &lt;=5.8.2</code></p>
<p> 　　　　　　<code>② 插件中存在wp_query调用且参数可控。</code></p>
<p>　　此次漏洞触发点位于 <code>“class-wp-tax-query.php”</code>文件中的 <code>“clean_query”</code>函数，通过传入特定参数，根据函数逻辑，可使函数<code>transform_query</code>不经处理直接逃逸返回，从而造成sql注入，以下是漏洞调用链分析<span id="more"></span>：</p>
<p>　　在<code>clean_query</code>函数中，使<code>$query[‘field’]</code>的取值为<code>‘term_taxonomy_id’</code>，并且<code>$query[‘include_children’]==false</code>或<code>is_taxonomy_hierarchical($query[‘taxonomy’]) ==false</code>即可跳过下图中的<code>if</code>判断，进入<code>transform_query</code>函数<!--more-->：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314142117659.png" alt="image-20220314142117659"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314142126887.png" alt="image-20220314142126887"></p>
<p>　　在<code>transform_query</code>函数中，由于我们提前传入了参数<code>$query[‘field’]== ‘term_taxonomy_id’</code>，因此该函数会不经处理直接返回：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144653960.png" alt="image-20220314144653960"></p>
<p>　　由于<code>clean_query</code>函数是由<code>get_sql_for_clause</code>调用的，在<code>transform_query</code>函数逃逸返回后，变量<code>$query[‘term’]</code>将拼接查询条件作为<code>sql</code>的查询语句，从而引发<code>sql</code>注入：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144727304.png" alt="image-20220314144727304"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144732504.png" alt="image-20220314144732504"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144736232.png" alt="image-20220314144736232"></p>
<p>　　此错误是<code>wp</code>核心调用的漏洞，但是<code>wp</code>核心的复用方式（<code>wp</code>自身调用<code>wp_query</code>）的共205处调用均未满足条件，故可在<code>wp</code>的插件&#x2F;主题中寻找符合条件的<code>WP_Query</code>函数来触发漏洞。</p>
<p><font color="red"><strong>FAQ：根据上述开篇讲到的，为什么漏洞是</strong><code>clean_query</code><strong>函数造成的，却要调用</strong><code>WP_Query</code><strong>来造成漏洞触发？</strong></font></p>
<p>　　这个是由<code>clean_query</code>函数的调用链决定的，经过调试溯源，可发现漏洞函数<code>clean_query</code>的最原始调用函数为<code>WP_Query</code>，这个可通过函数的调用栈看出：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145241051.png" alt="image-20220314145241051"></p>
<p>此函数的整个调用链如下：</p>
<p>WP_Query#__construct -&gt; WP_Query#query-&gt; WP_Query#get_posts -&gt;WP_Tax_Query#get_sql -&gt;WP_Tax_Query#get_sql_clauses-&gt;WP_Tax_Query#get_sql_for_query-&gt;WP_Tax_Query#get_sql_for_clause </p>
<p>　　在插件&#x2F;主题中调用<code>wp</code>核心函数<code>WP_Query</code>还涉及一个知识点，由于<code>wp</code>具有<code>ajax</code>异步调用请求接口，且插件&#x2F;主题调用<code>wp</code>核心函数时均使用该方法实现，故还需理解<code>wp</code>的<code>ajax</code>调用原理：</p>
<p>　　<font color="red"><em>WordPress的AJAX请求统一通过&#x2F;wp-admin&#x2F;admin-ajax.php这个URL来提交AJAX请求。通过在提交的FORM表单中添加action参数来获取在后台注册的AJAX处理函数。wp_ajax_{$action}或者wp_ajax_nopriv_{$action}中的{$action}就是前端AJAX请求时要提交的action参数内容。</em></font></p>
<p>　　也就是说，如果<code>ajax</code>请求 <code>http://域名/wp-admin/admin-ajax.php</code>，无论<code>action</code>参数是通过<code>post</code>或<code>get</code>方式传递的，<code>admin-ajax</code>都会去查找并执行对应的处理代码，这个可以从<code>wp</code>中的<code>admin-ajax.php</code>源码中看出：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145429979.png" alt="image-20220314145429979"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145433672.png" alt="image-20220314145433672"></p>
<p><font color="red"><strong>FAQ：</strong><code>wp_ajax_&#123;$action&#125;</code><strong>和</strong><code>wp_ajax_nopriv_&#123;$action&#125;</code><strong>之间有什么区别？</strong></font></p>
<p>　　<code>wp_ajax_&#123;$action&#125;</code> 是用户登录后所提交的<code>AJAX</code>处理函数，而<code>wp_ajax_nopriv_&#123;$action&#125;</code>是未登录用户的<code>AJAX</code>请求处理函数。意思为若插件&#x2F;主题代码中注册了<code>wp_ajax_nopriv_&#123;$action&#125;</code>函数，可无需登录直接调用对应的<code>ajax</code>请求。</p>
<h2 id="0x02-复现"><a href="#0x02-复现" class="headerlink" title="0x02 复现"></a>0x02 复现</h2><p>　　方便起见，直接在现有代码基础上构造触发漏洞的函数代码测试（实际环境可通过wp官网下载插件源码寻找测试）。</p>
<p>1.在<code>wp</code>的<code>“twentytwenty”</code>主题的<code>“function.php”</code>中添加无需用户登录的<code>ajax</code>调用请求代码：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145749257.png" alt="image-20220314145749257"></p>
<ol start="2">
<li>由于此<code>sql</code>注入默认无回显，测试环境需开启<code>wp</code>的<code>debug</code>模式使其输出错误信息方便观察：</li>
</ol>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145824552.png" alt="image-20220314145824552"></p>
<p>3.抓包输入<code>payload</code>：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145854649.png" alt="image-20220314145854649"></p>
<p>4.调试中的<code>sql</code>查询语句如下：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145918553.png" alt="image-20220314145918553"></p>
<p>5.数据回显：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145930120.png" alt="image-20220314145930120"></p>
<p>　　以上是开启了<code>wp</code>的<code>debug</code>模式测试的，真实环境默认不回显，可使用盲注或通过<code>dnslog/ceye</code>外带数据。</p>
<p>6.通过审计发现某插件存在注入漏洞，经过调试参数，修改<code>payload</code>结果如下：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220215115431-1-1024x525.png" alt="微信图片_20220215115431-1-1024x525"></p>
<hr>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
  <entry>
    <title>逆向分析并修复某服聊天Bug</title>
    <url>/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/</url>
    <content><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01   前言"></a>0x01   前言</h2><p>　　因为游戏是从国外某服直接汉化的，所以就有了“聊天框删除中文异常”的<code>bug</code>。其实也不算<code>bug</code>，因为是直接汉化的，所以并不存在处理中文的逻辑。<code>bug</code>具体现象为对话框输入的字删除时，一个汉字需要两次摁删除键才能删除，摁一次会留下一个”?”，如下图：<span id="more"></span></p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/bug%E7%8E%B0%E8%B1%A1.png" alt="bug现象"></p>
<h2 id="0x02-原因分析"><a href="#0x02-原因分析" class="headerlink" title="0x02   原因分析"></a>0x02   原因分析</h2><p>　　首先能想到的一条思路就是利用<code>CE</code>找到字符串的写入地址，设置内存访问断点，找到调用该地址的函数从而定位问题所在。进入游戏，<code>CE</code>中打开游戏进程，在对话框中随便输入字符串，<code>CE</code>搜索结果如下：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E6%B1%89%E5%AD%97%E5%AD%98%E6%94%BE%E5%9C%B0%E5%9D%80.png" alt="汉字存放地址"></p>
<p>　　红框标注绿色的地址即为字符串实际存放的地址，用<code>od</code>附加的方式打开游戏主模块<code>so3d.exe</code>，<code>F9</code>继续运行，在<code>od</code>数据窗口中<code>ctrl+g</code>输入<code>01172050</code>，找到了存放该字符串的内存地址，<code>ASCII</code>显示为<code>“hello”</code>。</p>
<p>　　反复测试发现，对话框中字符串的写入地址总是为<code>01172050</code>，即为字符串写入的真实地址，既然找到了字符串写入的地址，不妨先看看写入过程中程序都进行了哪些操作。清空游戏对话框内容，在数据窗口<code>01172050</code>第一个字节处设置内存写入断点，游戏中输入字符后<code>od</code>中断到如下位置：<img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E5%90%8Eod%E6%96%AD%E4%B8%8B.png" alt="输入字符后od断下"></p>
<p>　　相应代码已经标注了注释。通过分析上下文，程序写入数据的流程为：堆栈取出要本次写入字符的<code>ascii</code>码值放入<code>bl</code>，将<code>bl</code>与<code>0x26（ASCII为“&amp;”）</code>比较，若相等，则跳过本次写入，然后依次将<code>esi+118</code>和<code>esi+114</code>中存放的字符串数组中的索引值与<code>esi+110</code>中存放的数值<code>（0x41）</code>作比较，若大于或等于，则跳过本次写入，这意味着对话框中最多只能输入<code>64</code>个字符。符合写入条件后，将索引值赋给<code>ecx</code>，在<code>0061775E</code>处用数组下标寻址的方式将<code>bl</code>写入地址，其中<code>esi+0x4</code>为要写入字符串数组的首地址，<code>ecx</code>为索引值，写入后，将三处存放的数组索引值<code>（esi+528、esi+118、esi+114）</code>依次<code>+1</code>，再将写入地址的后一个字节清零后返回。</p>
<p>　　紧接着分析程序删除数据的流程。一个思路是在<code>01172050</code>处下内存访问断点，在游戏对话框中删除字符时，<code>od</code>便会中断在删除字符的处理流程中，但实际操作发现一旦设置内存访问断点，<code>od</code>会反复中断在其他函数中，无法定位到删除函数里，看来有其他函数在反复访问该地址进行操作，只能换条思路。因为删除字符肯定会改写字符数组中的最后一个字符，因此可以在最后一个字节处设置内存写入断点，先用<code>“hello”</code>做测试，在它的最后一个字节处，也就是 <code>01172050+4</code>的位置处设置断点，删除字符后，<code>od</code>中断到如下位置：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2od%E6%96%AD%E4%B8%8B.png" alt="删除字符串od断下"></p>
<p>　　通过分析上下文，程序删除数据的流程与写入流程相反，就不附注释了。流程为：将<code>esi+528</code>和<code>esi+118</code>处存放的字符串数组索引值依次减<code>1</code>，随后将<code>esi+528</code>处的索引值赋给<code>ecx</code>，依次判断各个存放的索引值与<code>ebx（ebx为0）</code>的关系，若小于，则会将索引值修改为<code>ebx</code>， 符合删除条件后，将索引值赋给<code>ecx</code>，在<code>00617A32</code>处用数组下标寻址的方式将<code>bl（ebx为0）</code>写入地址，其中<code>esi+0x4</code>为要写入字符串数组的首地址，<code>ecx</code>为索引值，写入后，将删除字节的位置清零并返回。</p>
<p>　　到此，<code>bug</code>产生的原因就很清楚了，本程序中，要想删除一个汉字，有两种途径，一种是将删除函数执行两次（因为在删除函数中每次只操作一个字节）、一种是一次删除两个字节。 跟进程序可以发现，根本没有以上所述的两种方式，程序只会一个字节一个字节的进行操作，其实很正常，因为开篇提到了，此游戏是直接用外服汉化来的，没有对程序进行修改，又因为一个汉字由两个字节组成，所以摁一次删除键，程序只会执行一次删除流程并且只会删除一个字节，从而留下了另外一个字节，显示为”?”。</p>
<h2 id="0x03-修复"><a href="#0x03-修复" class="headerlink" title="0x03   修复"></a>0x03   修复</h2><p>　　找到问题所在，并且清楚了程序写入和删除的流程后，写补丁就容易的多了。实现汉字的删除有很多思路方法，打补丁也有很多种方式，本次采用增加判断，一次操作两个字节的方式实现删除，打补丁的方式采用<code>SMC</code>补丁。</p>
<p>　　<code>PE</code>文件的各区段为了实现大小成倍对齐，会在各区段末尾处留下或多或少的无用字节，用<code>“00”</code>填充，用<code>LordPE</code>打开游戏主模块<code>so3d.exe</code>,区段信息如下：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/so3d%E5%8C%BA%E6%AE%B5%E4%BF%A1%E6%81%AF.png" alt="so3d区段信息"></p>
<p>　　区段表显示第二个区段<code>.rdata</code>开始的<code>ROffset（文件偏移）</code>为<code>276400</code>，将<code>so3d.exe</code>用 <code>WinHex</code>打开，<code>Alt+G</code>输入<code>276400</code>，转到相对于文件开头处的<code>276400</code>，即下图所示的位置：<img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/pe%E6%96%87%E4%BB%B6%E5%8C%BA%E6%AE%B5%E7%A9%BA%E9%9A%99.png" alt="pe文件区段空隙"></p>
<p>　　箭头所指位置为第二个区段<code>.rdata</code>的开始处，红框标注的即为为了实现对齐而增加的无用字节，选择在<code>276310</code>处写入我们的补丁代码。</p>
<p>　　首先要找到<code> 276310</code>在内存中的位置，通过简单计算即可得到。 查看区段表， <code>276310</code>处在第一区段中，是从文件开头处偏移<code>400</code>的位置开始的，因此用 <code>276310-400</code>计算出相对于第一区段的偏移为<code>275910</code>，加上内存中第一区段的加载基址<code>00401000</code>得到<code>676F10</code>,在<code>od</code>中跳转到<code> 676F10</code>，如图下所示：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E8%A1%A5%E4%B8%81%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80.png" alt="补丁代码地址"></p>
<p>　　要想利用<code>jmp</code>指令让程序跳转到我们指定的位置执行，就需要修改原程序的执行流程。前面说到，在<code>00617A32</code>是执行删除的指令，<code>jmp</code>跳转指令共需要<code>5</code>个字节， <code>00617A32</code>所处的指令只有四个字节，不满足改写要求，<code>00617A32</code>前一条指令大于五个字节，因此在此处修改，修改如下：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9%E5%8E%9F%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4-16721233999171.png" alt="补丁修改原跳转指令"></p>
<p>　　<code>676F10</code> 处的补丁代码及注释如下：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E8%B7%B3%E8%BD%AC%E5%A4%84%E7%9A%84%E8%A1%A5%E4%B8%81%E4%BB%A3%E7%A0%81.png" alt="跳转处的补丁代码"></p>
<p>　　<code>00676F18</code>和<code>00676f1D</code>处的指令为判断字符是否为汉字，因为<code>0x7A</code>在<code>ASCII</code>中为小写的<code>“z”</code>，若小于<code>7A</code>,则删除一个字节，否则为汉字删除两个字节，将这两处修改到可执行文件并保存，替换原文件后成功修复该<code>bug</code>。文末附上修改前后效果：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E4%BF%AE%E6%94%B9%E5%89%8D.gif" alt="修改前"></p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E4%BF%AE%E6%94%B9%E5%90%8E.gif" alt="修改后"></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
</search>
