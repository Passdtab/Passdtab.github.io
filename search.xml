<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RDP远程桌面图像复现</title>
    <url>/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01    原理"></a>0x01    原理</h2><p>　　在使用远程桌面连接服务器时，客户端会将缓存数据保存在当前用户的应用程序数据目录中，这部分数据在会话结束后也不会清除。本文将通过原理分析、数据类型分析，通过手动及自动化的方法对数据拆分合并，再现曾经连过的远程桌面的画面。<span id="more"></span></p>
<h2 id="0x02-手动实现"><a href="#0x02-手动实现" class="headerlink" title="0x02   手动实现"></a>0x02   手动实现</h2><p>　　早期的RDP为了加速连接时的显示，减少数据量的传输，采用了一种技术为<code>BMChache</code>，即位图缓存。<code>BMChache</code>分为两种类型，一种是<code>Bitmap Chaches</code>(位图缓存)，一种是<code>Persisten Bitmap Chaches</code>(持久位图缓存)。区别在于，前一种是临时缓存，与<code>RDP</code>会话生命周期绑定，后一种是持久化的缓存，不受到<code>RDP</code>会话生命周期的限制，即使会话结束后，内容依然会持久化的存在于文件中。</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/%E6%8C%81%E4%B9%85%E4%BD%8D%E5%9B%BE%E7%BC%93%E5%AD%98.png" alt="持久位图缓存"></p>
<p>　　而<code>windows</code>默认是开启持久位图缓存的</p>
<p>　　在<code>Windows XP</code>中，其持久位图缓存文件存储在 ：</p>
<p><font color="red">*%USERPROFILE%\Local Settings\Application Data\Microsoft\Terminal Server Client\Cache\*</font>路径中</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/winxp%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.png" alt="winxp存放位置"></p>
<p>　　在Windows 7及更高版本系统中，其文件存储在 ：</p>
<p><font color="red">*%USERPROFILE%\AppData\Local\Microsoft\Terminal Server Client\Cache\*</font>路径中</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/win7%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.png" alt="win7存放位置"></p>
<p>　　而<code>bmc</code>缓存文件数据格式如下：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmc%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6.png" alt="bmc缓存文件"></p>
<p>　　因此手动复现的原理就很简单了，将<code>.bmc/.bin</code>文件按照数据格式拆分出一个完整的位图文件数据，再按照<code>bmp</code>文件格式重组文件头，最终进行组合形成一个完整的<code>bmp</code>位图文件：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmp%E6%96%87%E4%BB%B6%E9%87%8D%E7%BB%84%E6%B5%81%E7%A8%8B.png" alt="bmp文件重组流程"></p>
<p>　　以上述文件<code>bcache24.bmc</code>文件为例，其单个位图数据大小为0x1400，即5120，因此从<code>bmc</code>图像数据中复制5120个字节数据到新文件中，按照<code>bmp</code>文件数据格式重组<code>bmp</code>文件头，形成一个完整的<code>bmp</code>图像：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmp%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt="bmp文件头"></p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/%E5%AE%8C%E6%95%B4bmp%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE.png" alt="完整bmp文件数据"></p>
<p>　　最终成功手动提取出了文件中的缓存图像：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96.png" alt="缓存文件提取"></p>
<h2 id="0x03-自动化工具"><a href="#0x03-自动化工具" class="headerlink" title="0x03   自动化工具"></a>0x03   自动化工具</h2><p>　　一个<code>bmc</code>缓存文件能提取出成百上千个图片文件，因此全部手动提取不太现实，好在已经有前人造好了轮子，首先第一个工具为<code>bmc-tools</code>,它是一个专门解析<code>rdp</code>位图缓存的工具，可对<code>bcache*.bmc和cache????.bin</code>文件进行解析，拆分出其中的位图文件，使用效果如下：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmc-tools%E6%8F%90%E5%8F%96.png" alt="bmc-tools提取"></p>
<p>　　第二个工具为 <code>RdpCacheStitcher</code>，可以使用该图形化工具对原始 <code>RDP</code> 缓存位图进行手动拼接，实现完整的屏幕截图。它提供了一个图形用户拼接的界面和位图存放界面。</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/RdpCacheStitcher.png" alt="RdpCacheStitcher"></p>
<p>　　可以看出，该工具对提取出的所有缓存图像进行了<code>ai</code>算法的识别组合，但是算法不够精准，有些地方是错乱的，因此还需要手动进行调整。</p>
<p>　　第三个工具为<code>BMC Viewer</code>，可以直接对<code>bmc</code>文件进行解析查看，工具会进行<code>ai</code>识图并自动进行拼接，虽然是个一键自动化工具，但是效果显而易见，没有第二个好，但是全局可视化上效果还是不错的。</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/BMC_Viewer.png" alt="BMC_Viewer"></p>
<p>　　这么看来，最终拼的还是<code>ai</code>算法，只要<code>ai</code>算法够精准，完全有可能实现图片拼接，最终还原成一个完整的图像，但是就目前看来，实战中完全够用，真要是还原完整图像的话那应该就是取证方面需要做到的事情了。</p>
]]></content>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>wordpress漏洞-cve-2022-21661-原理及复现</title>
    <url>/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01  原理"></a>0x01  原理</h2><p>　<code>利用条件：① wordpress &lt;=5.8.2</code></p>
<p> 　　　　　　<code>② 插件中存在wp_query调用且参数可控。</code></p>
<p>　　此次漏洞触发点位于 <code>“class-wp-tax-query.php”</code>文件中的 <code>“clean_query”</code>函数，通过传入特定参数，根据函数逻辑，可使函数<code>transform_query</code>不经处理直接逃逸返回，从而造成sql注入，以下是漏洞调用链分析<span id="more"></span>：</p>
<p>　　在<code>clean_query</code>函数中，使<code>$query[‘field’]</code>的取值为<code>‘term_taxonomy_id’</code>，并且<code>$query[‘include_children’]==false</code>或<code>is_taxonomy_hierarchical($query[‘taxonomy’]) ==false</code>即可跳过下图中的<code>if</code>判断，进入<code>transform_query</code>函数<!--more-->：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314142117659.png" alt="image-20220314142117659"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314142126887.png" alt="image-20220314142126887"></p>
<p>　　在<code>transform_query</code>函数中，由于我们提前传入了参数<code>$query[‘field’]== ‘term_taxonomy_id’</code>，因此该函数会不经处理直接返回：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144653960.png" alt="image-20220314144653960"></p>
<p>　　由于<code>clean_query</code>函数是由<code>get_sql_for_clause</code>调用的，在<code>transform_query</code>函数逃逸返回后，变量<code>$query[‘term’]</code>将拼接查询条件作为<code>sql</code>的查询语句，从而引发<code>sql</code>注入：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144727304.png" alt="image-20220314144727304"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144732504.png" alt="image-20220314144732504"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144736232.png" alt="image-20220314144736232"></p>
<p>　　此错误是<code>wp</code>核心调用的漏洞，但是<code>wp</code>核心的复用方式（<code>wp</code>自身调用<code>wp_query</code>）的共205处调用均未满足条件，故可在<code>wp</code>的插件&#x2F;主题中寻找符合条件的<code>WP_Query</code>函数来触发漏洞。</p>
<p><font color="red"><strong>FAQ：根据上述开篇讲到的，为什么漏洞是</strong><code>clean_query</code><strong>函数造成的，却要调用</strong><code>WP_Query</code><strong>来造成漏洞触发？</strong></font></p>
<p>　　这个是由<code>clean_query</code>函数的调用链决定的，经过调试溯源，可发现漏洞函数<code>clean_query</code>的最原始调用函数为<code>WP_Query</code>，这个可通过函数的调用栈看出：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145241051.png" alt="image-20220314145241051"></p>
<p>此函数的整个调用链如下：</p>
<p>WP_Query#__construct -&gt; WP_Query#query-&gt; WP_Query#get_posts -&gt;WP_Tax_Query#get_sql -&gt;WP_Tax_Query#get_sql_clauses-&gt;WP_Tax_Query#get_sql_for_query-&gt;WP_Tax_Query#get_sql_for_clause </p>
<p>　　在插件&#x2F;主题中调用<code>wp</code>核心函数<code>WP_Query</code>还涉及一个知识点，由于<code>wp</code>具有<code>ajax</code>异步调用请求接口，且插件&#x2F;主题调用<code>wp</code>核心函数时均使用该方法实现，故还需理解<code>wp</code>的<code>ajax</code>调用原理：</p>
<p>　　<font color="red"><em>WordPress的AJAX请求统一通过&#x2F;wp-admin&#x2F;admin-ajax.php这个URL来提交AJAX请求。通过在提交的FORM表单中添加action参数来获取在后台注册的AJAX处理函数。wp_ajax_{$action}或者wp_ajax_nopriv_{$action}中的{$action}就是前端AJAX请求时要提交的action参数内容。</em></font></p>
<p>　　也就是说，如果<code>ajax</code>请求 <code>http://域名/wp-admin/admin-ajax.php</code>，无论<code>action</code>参数是通过<code>post</code>或<code>get</code>方式传递的，<code>admin-ajax</code>都会去查找并执行对应的处理代码，这个可以从<code>wp</code>中的<code>admin-ajax.php</code>源码中看出：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145429979.png" alt="image-20220314145429979"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145433672.png" alt="image-20220314145433672"></p>
<p><font color="red"><strong>FAQ：</strong><code>wp_ajax_&#123;$action&#125;</code><strong>和</strong><code>wp_ajax_nopriv_&#123;$action&#125;</code><strong>之间有什么区别？</strong></font></p>
<p>　　<code>wp_ajax_&#123;$action&#125;</code> 是用户登录后所提交的<code>AJAX</code>处理函数，而<code>wp_ajax_nopriv_&#123;$action&#125;</code>是未登录用户的<code>AJAX</code>请求处理函数。意思为若插件&#x2F;主题代码中注册了<code>wp_ajax_nopriv_&#123;$action&#125;</code>函数，可无需登录直接调用对应的<code>ajax</code>请求。</p>
<h2 id="0x02-复现"><a href="#0x02-复现" class="headerlink" title="0x02 复现"></a>0x02 复现</h2><p>　　方便起见，直接在现有代码基础上构造触发漏洞的函数代码测试（实际环境可通过wp官网下载插件源码寻找测试）。</p>
<p>1.在<code>wp</code>的<code>“twentytwenty”</code>主题的<code>“function.php”</code>中添加无需用户登录的<code>ajax</code>调用请求代码：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145749257.png" alt="image-20220314145749257"></p>
<ol start="2">
<li>由于此<code>sql</code>注入默认无回显，测试环境需开启<code>wp</code>的<code>debug</code>模式使其输出错误信息方便观察：</li>
</ol>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145824552.png" alt="image-20220314145824552"></p>
<p>3.抓包输入<code>payload</code>：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145854649.png" alt="image-20220314145854649"></p>
<p>4.调试中的<code>sql</code>查询语句如下：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145918553.png" alt="image-20220314145918553"></p>
<p>5.数据回显：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145930120.png" alt="image-20220314145930120"></p>
<p>　　以上是开启了<code>wp</code>的<code>debug</code>模式测试的，真实环境默认不回显，可使用盲注或通过<code>dnslog/ceye</code>外带数据。</p>
<p>6.通过审计发现某插件存在注入漏洞，经过调试参数，修改<code>payload</code>结果如下：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220215115431-1-1024x525.png" alt="微信图片_20220215115431-1-1024x525"></p>
<hr>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
</search>
