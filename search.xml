<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RDP远程桌面图像复现</title>
    <url>/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01    原理"></a>0x01    原理</h2><p>　　在使用远程桌面连接服务器时，客户端会将缓存数据保存在当前用户的应用程序数据目录中，这部分数据在会话结束后也不会清除。本文将通过原理分析、数据类型分析，通过手动及自动化的方法对数据拆分合并，再现曾经连过的远程桌面的画面。<span id="more"></span></p>
<h2 id="0x02-手动实现"><a href="#0x02-手动实现" class="headerlink" title="0x02   手动实现"></a>0x02   手动实现</h2><p>　　早期的RDP为了加速连接时的显示，减少数据量的传输，采用了一种技术为<code>BMChache</code>，即位图缓存。<code>BMChache</code>分为两种类型，一种是<code>Bitmap Chaches</code>(位图缓存)，一种是<code>Persisten Bitmap Chaches</code>(持久位图缓存)。区别在于，前一种是临时缓存，与<code>RDP</code>会话生命周期绑定，后一种是持久化的缓存，不受到<code>RDP</code>会话生命周期的限制，即使会话结束后，内容依然会持久化的存在于文件中。</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/%E6%8C%81%E4%B9%85%E4%BD%8D%E5%9B%BE%E7%BC%93%E5%AD%98.png" alt="持久位图缓存"></p>
<p>　　而<code>windows</code>默认是开启持久位图缓存的</p>
<p>　　在<code>Windows XP</code>中，其持<em>久位图</em>缓存文件存储在 ：</p>
<p><font color="red">%USERPROFILE%\Local Settings\Application Data\Microsoft\Terminal Server Client\Cache \</font>路径中</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/winxp%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.png" alt="winxp存放位置"></p>
<p>　　在Windows 7及更高版本系统中，其文件存储在 ：</p>
<p><font color="red">%USERPROFILE%\AppData\Local\Microsoft\Terminal Server Client\Cache\</font>路径中</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/win7%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.png" alt="win7存放位置"></p>
<p>　　而<code>bmc</code>缓存文件数据格式如下：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmc%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6.png" alt="bmc缓存文件"></p>
<p>　　因此手动复现的原理就很简单了，将<code>.bmc/.bin</code>文件按照数据格式拆分出一个完整的位图文件数据，再按照<code>bmp</code>文件格式重组文件头，最终进行组合形成一个完整的<code>bmp</code>位图文件：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmp%E6%96%87%E4%BB%B6%E9%87%8D%E7%BB%84%E6%B5%81%E7%A8%8B.png" alt="bmp文件重组流程"></p>
<p>　　以上述文件<code>bcache24.bmc</code>文件为例，其单个位图数据大小为0x1400，即5120，因此从<code>bmc</code>图像数据中复制5120个字节数据到新文件中，按照<code>bmp</code>文件数据格式重组<code>bmp</code>文件头，形成一个完整的<code>bmp</code>图像：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmp%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt="bmp文件头"></p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/%E5%AE%8C%E6%95%B4bmp%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE.png" alt="完整bmp文件数据"></p>
<p>　　最终成功手动提取出了文件中的缓存图像：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96.png" alt="缓存文件提取"></p>
<h2 id="0x03-自动化工具"><a href="#0x03-自动化工具" class="headerlink" title="0x03   自动化工具"></a>0x03   自动化工具</h2><p>　　一个<code>bmc</code>缓存文件能提取出成百上千个图片文件，因此全部手动提取不太现实，好在已经有前人造好了轮子，首先第一个工具为<code>bmc-tools</code>,它是一个专门解析<code>rdp</code>位图缓存的工具，可对<code>bcache*.bmc和cache????.bin</code>文件进行解析，拆分出其中的位图文件，使用效果如下：</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/bmc-tools%E6%8F%90%E5%8F%96.png" alt="bmc-tools提取"></p>
<p>　　第二个工具为 <code>RdpCacheStitcher</code>，可以使用该图形化工具对原始 <code>RDP</code> 缓存位图进行手动拼接，实现完整的屏幕截图。它提供了一个图形用户拼接的界面和位图存放界面。</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/RdpCacheStitcher.png" alt="RdpCacheStitcher"></p>
<p>　　可以看出，该工具对提取出的所有缓存图像进行了<code>ai</code>算法的识别组合，但是算法不够精准，有些地方是错乱的，因此还需要手动进行调整。</p>
<p>　　第三个工具为<code>BMC Viewer</code>，可以直接对<code>bmc</code>文件进行解析查看，工具会进行<code>ai</code>识图并自动进行拼接，虽然是个一键自动化工具，但是效果显而易见，没有第二个好，但是全局可视化上效果还是不错的。</p>
<p><img src="/2022/12/26/RDP%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E5%9B%BE%E5%83%8F%E5%A4%8D%E7%8E%B0/BMC_Viewer.png" alt="BMC_Viewer"></p>
<p>　　这么看来，最终拼的还是<code>ai</code>算法，只要<code>ai</code>算法够精准，完全有可能实现图片拼接，最终还原成一个完整的图像，但是就目前看来，实战中完全够用，真要是还原完整图像的话那应该就是取证方面需要做到的事情了。</p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
  </entry>
  <entry>
    <title>wordpress漏洞-cve-2022-21661-原理及复现</title>
    <url>/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01  原理"></a>0x01  原理</h2><p>　<code>利用条件：① wordpress &lt;=5.8.2</code></p>
<p> 　　　　　　<code>② 插件中存在wp_query调用且参数可控。</code></p>
<p>　　此次漏洞触发点位于 <code>“class-wp-tax-query.php”</code>文件中的 <code>“clean_query”</code>函数，通过传入特定参数，根据函数逻辑，可使函数<code>transform_query</code>不经处理直接逃逸返回，从而造成sql注入，以下是漏洞调用链分析<span id="more"></span>：</p>
<p>　　在<code>clean_query</code>函数中，使<code>$query[‘field’]</code>的取值为<code>‘term_taxonomy_id’</code>，并且<code>$query[‘include_children’]==false</code>或<code>is_taxonomy_hierarchical($query[‘taxonomy’]) ==false</code>即可跳过下图中的<code>if</code>判断，进入<code>transform_query</code>函数<!--more-->：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314142117659.png" alt="image-20220314142117659"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314142126887.png" alt="image-20220314142126887"></p>
<p>　　在<code>transform_query</code>函数中，由于我们提前传入了参数<code>$query[‘field’]== ‘term_taxonomy_id’</code>，因此该函数会不经处理直接返回：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144653960.png" alt="image-20220314144653960"></p>
<p>　　由于<code>clean_query</code>函数是由<code>get_sql_for_clause</code>调用的，在<code>transform_query</code>函数逃逸返回后，变量<code>$query[‘term’]</code>将拼接查询条件作为<code>sql</code>的查询语句，从而引发<code>sql</code>注入：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144727304.png" alt="image-20220314144727304"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144732504.png" alt="image-20220314144732504"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314144736232.png" alt="image-20220314144736232"></p>
<p>　　此错误是<code>wp</code>核心调用的漏洞，但是<code>wp</code>核心的复用方式（<code>wp</code>自身调用<code>wp_query</code>）的共205处调用均未满足条件，故可在<code>wp</code>的插件&#x2F;主题中寻找符合条件的<code>WP_Query</code>函数来触发漏洞。</p>
<p><font color="red"><strong>FAQ：根据上述开篇讲到的，为什么漏洞是</strong><code>clean_query</code><strong>函数造成的，却要调用</strong><code>WP_Query</code><strong>来造成漏洞触发？</strong></font></p>
<p>　　这个是由<code>clean_query</code>函数的调用链决定的，经过调试溯源，可发现漏洞函数<code>clean_query</code>的最原始调用函数为<code>WP_Query</code>，这个可通过函数的调用栈看出：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145241051.png" alt="image-20220314145241051"></p>
<p>此函数的整个调用链如下：</p>
<p>WP_Query#__construct -&gt; WP_Query#query-&gt; WP_Query#get_posts -&gt;WP_Tax_Query#get_sql -&gt;WP_Tax_Query#get_sql_clauses-&gt;WP_Tax_Query#get_sql_for_query-&gt;WP_Tax_Query#get_sql_for_clause </p>
<p>　　在插件&#x2F;主题中调用<code>wp</code>核心函数<code>WP_Query</code>还涉及一个知识点，由于<code>wp</code>具有<code>ajax</code>异步调用请求接口，且插件&#x2F;主题调用<code>wp</code>核心函数时均使用该方法实现，故还需理解<code>wp</code>的<code>ajax</code>调用原理：</p>
<p>　　<font color="red"><em>WordPress的AJAX请求统一通过&#x2F;wp-admin&#x2F;admin-ajax.php这个URL来提交AJAX请求。通过在提交的FORM表单中添加action参数来获取在后台注册的AJAX处理函数。wp_ajax_{$action}或者wp_ajax_nopriv_{$action}中的{$action}就是前端AJAX请求时要提交的action参数内容。</em></font></p>
<p>　　也就是说，如果<code>ajax</code>请求 <code>http://域名/wp-admin/admin-ajax.php</code>，无论<code>action</code>参数是通过<code>post</code>或<code>get</code>方式传递的，<code>admin-ajax</code>都会去查找并执行对应的处理代码，这个可以从<code>wp</code>中的<code>admin-ajax.php</code>源码中看出：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145429979.png" alt="image-20220314145429979"></p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145433672.png" alt="image-20220314145433672"></p>
<p><font color="red"><strong>FAQ：</strong><code>wp_ajax_&#123;$action&#125;</code><strong>和</strong><code>wp_ajax_nopriv_&#123;$action&#125;</code><strong>之间有什么区别？</strong></font></p>
<p>　　<code>wp_ajax_&#123;$action&#125;</code> 是用户登录后所提交的<code>AJAX</code>处理函数，而<code>wp_ajax_nopriv_&#123;$action&#125;</code>是未登录用户的<code>AJAX</code>请求处理函数。意思为若插件&#x2F;主题代码中注册了<code>wp_ajax_nopriv_&#123;$action&#125;</code>函数，可无需登录直接调用对应的<code>ajax</code>请求。</p>
<h2 id="0x02-复现"><a href="#0x02-复现" class="headerlink" title="0x02 复现"></a>0x02 复现</h2><p>　　方便起见，直接在现有代码基础上构造触发漏洞的函数代码测试（实际环境可通过wp官网下载插件源码寻找测试）。</p>
<p>1.在<code>wp</code>的<code>“twentytwenty”</code>主题的<code>“function.php”</code>中添加无需用户登录的<code>ajax</code>调用请求代码：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145749257.png" alt="image-20220314145749257"></p>
<ol start="2">
<li>由于此<code>sql</code>注入默认无回显，测试环境需开启<code>wp</code>的<code>debug</code>模式使其输出错误信息方便观察：</li>
</ol>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145824552.png" alt="image-20220314145824552"></p>
<p>3.抓包输入<code>payload</code>：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145854649.png" alt="image-20220314145854649"></p>
<p>4.调试中的<code>sql</code>查询语句如下：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145918553.png" alt="image-20220314145918553"></p>
<p>5.数据回显：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20220314145930120.png" alt="image-20220314145930120"></p>
<p>　　以上是开启了<code>wp</code>的<code>debug</code>模式测试的，真实环境默认不回显，可使用盲注或通过<code>dnslog/ceye</code>外带数据。</p>
<p>6.通过审计发现某插件存在注入漏洞，经过调试参数，修改<code>payload</code>结果如下：</p>
<p><img src="/2022/03/14/wordpress%E6%BC%8F%E6%B4%9E-cve-2022-21661-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220215115431-1-1024x525.png" alt="微信图片_20220215115431-1-1024x525"></p>
<hr>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
  <entry>
    <title>逆向分析并修复某服聊天Bug</title>
    <url>/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/</url>
    <content><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01   前言"></a>0x01   前言</h2><p>　　因为游戏是从国外某服直接汉化的，所以就有了“聊天框删除中文异常”的<code>bug</code>。其实也不算<code>bug</code>，因为是直接汉化的，所以并不存在处理中文的逻辑。<code>bug</code>具体现象为对话框输入的字删除时，一个汉字需要两次摁删除键才能删除，摁一次会留下一个”?”，如下图：<span id="more"></span></p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/bug%E7%8E%B0%E8%B1%A1.png" alt="bug现象"></p>
<h2 id="0x02-原因分析"><a href="#0x02-原因分析" class="headerlink" title="0x02   原因分析"></a>0x02   原因分析</h2><p>　　首先能想到的一条思路就是利用<code>CE</code>找到字符串的写入地址，设置内存访问断点，找到调用该地址的函数从而定位问题所在。进入游戏，<code>CE</code>中打开游戏进程，在对话框中随便输入字符串，<code>CE</code>搜索结果如下：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E6%B1%89%E5%AD%97%E5%AD%98%E6%94%BE%E5%9C%B0%E5%9D%80.png" alt="汉字存放地址"></p>
<p>　　红框标注绿色的地址即为字符串实际存放的地址，用<code>od</code>附加的方式打开游戏主模块<code>so3d.exe</code>，<code>F9</code>继续运行，在<code>od</code>数据窗口中<code>ctrl+g</code>输入<code>01172050</code>，找到了存放该字符串的内存地址，<code>ASCII</code>显示为<code>“hello”</code>。</p>
<p>　　反复测试发现，对话框中字符串的写入地址总是为<code>01172050</code>，即为字符串写入的真实地址，既然找到了字符串写入的地址，不妨先看看写入过程中程序都进行了哪些操作。清空游戏对话框内容，在数据窗口<code>01172050</code>第一个字节处设置内存写入断点，游戏中输入字符后<code>od</code>中断到如下位置：<img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E5%90%8Eod%E6%96%AD%E4%B8%8B.png" alt="输入字符后od断下"></p>
<p>　　相应代码已经标注了注释。通过分析上下文，程序写入数据的流程为：堆栈取出要本次写入字符的<code>ascii</code>码值放入<code>bl</code>，将<code>bl</code>与<code>0x26（ASCII为“&amp;”）</code>比较，若相等，则跳过本次写入，然后依次将<code>esi+118</code>和<code>esi+114</code>中存放的字符串数组中的索引值与<code>esi+110</code>中存放的数值<code>（0x41）</code>作比较，若大于或等于，则跳过本次写入，这意味着对话框中最多只能输入<code>64</code>个字符。符合写入条件后，将索引值赋给<code>ecx</code>，在<code>0061775E</code>处用数组下标寻址的方式将<code>bl</code>写入地址，其中<code>esi+0x4</code>为要写入字符串数组的首地址，<code>ecx</code>为索引值，写入后，将三处存放的数组索引值<code>（esi+528、esi+118、esi+114）</code>依次<code>+1</code>，再将写入地址的后一个字节清零后返回。</p>
<p>　　紧接着分析程序删除数据的流程。一个思路是在<code>01172050</code>处下内存访问断点，在游戏对话框中删除字符时，<code>od</code>便会中断在删除字符的处理流程中，但实际操作发现一旦设置内存访问断点，<code>od</code>会反复中断在其他函数中，无法定位到删除函数里，看来有其他函数在反复访问该地址进行操作，只能换条思路。因为删除字符肯定会改写字符数组中的最后一个字符，因此可以在最后一个字节处设置内存写入断点，先用<code>“hello”</code>做测试，在它的最后一个字节处，也就是 <code>01172050+4</code>的位置处设置断点，删除字符后，<code>od</code>中断到如下位置：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2od%E6%96%AD%E4%B8%8B.png" alt="删除字符串od断下"></p>
<p>　　通过分析上下文，程序删除数据的流程与写入流程相反，就不附注释了。流程为：将<code>esi+528</code>和<code>esi+118</code>处存放的字符串数组索引值依次减<code>1</code>，随后将<code>esi+528</code>处的索引值赋给<code>ecx</code>，依次判断各个存放的索引值与<code>ebx（ebx为0）</code>的关系，若小于，则会将索引值修改为<code>ebx</code>， 符合删除条件后，将索引值赋给<code>ecx</code>，在<code>00617A32</code>处用数组下标寻址的方式将<code>bl（ebx为0）</code>写入地址，其中<code>esi+0x4</code>为要写入字符串数组的首地址，<code>ecx</code>为索引值，写入后，将删除字节的位置清零并返回。</p>
<p>　　到此，<code>bug</code>产生的原因就很清楚了，本程序中，要想删除一个汉字，有两种途径，一种是将删除函数执行两次（因为在删除函数中每次只操作一个字节）、一种是一次删除两个字节。 跟进程序可以发现，根本没有以上所述的两种方式，程序只会一个字节一个字节的进行操作，其实很正常，因为开篇提到了，此游戏是直接用外服汉化来的，没有对程序进行修改，又因为一个汉字由两个字节组成，所以摁一次删除键，程序只会执行一次删除流程并且只会删除一个字节，从而留下了另外一个字节，显示为”?”。</p>
<h2 id="0x03-修复"><a href="#0x03-修复" class="headerlink" title="0x03   修复"></a>0x03   修复</h2><p>　　找到问题所在，并且清楚了程序写入和删除的流程后，写补丁就容易的多了。实现汉字的删除有很多思路方法，打补丁也有很多种方式，本次采用增加判断，一次操作两个字节的方式实现删除，打补丁的方式采用<code>SMC</code>补丁。</p>
<p>　　<code>PE</code>文件的各区段为了实现大小成倍对齐，会在各区段末尾处留下或多或少的无用字节，用<code>“00”</code>填充，用<code>LordPE</code>打开游戏主模块<code>so3d.exe</code>,区段信息如下：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/so3d%E5%8C%BA%E6%AE%B5%E4%BF%A1%E6%81%AF.png" alt="so3d区段信息"></p>
<p>　　区段表显示第二个区段<code>.rdata</code>开始的<code>ROffset（文件偏移）</code>为<code>276400</code>，将<code>so3d.exe</code>用 <code>WinHex</code>打开，<code>Alt+G</code>输入<code>276400</code>，转到相对于文件开头处的<code>276400</code>，即下图所示的位置：<img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/pe%E6%96%87%E4%BB%B6%E5%8C%BA%E6%AE%B5%E7%A9%BA%E9%9A%99.png" alt="pe文件区段空隙"></p>
<p>　　箭头所指位置为第二个区段<code>.rdata</code>的开始处，红框标注的即为为了实现对齐而增加的无用字节，选择在<code>276310</code>处写入我们的补丁代码。</p>
<p>　　首先要找到<code> 276310</code>在内存中的位置，通过简单计算即可得到。 查看区段表， <code>276310</code>处在第一区段中，是从文件开头处偏移<code>400</code>的位置开始的，因此用 <code>276310-400</code>计算出相对于第一区段的偏移为<code>275910</code>，加上内存中第一区段的加载基址<code>00401000</code>得到<code>676F10</code>,在<code>od</code>中跳转到<code> 676F10</code>，如图下所示：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E8%A1%A5%E4%B8%81%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80.png" alt="补丁代码地址"></p>
<p>　　要想利用<code>jmp</code>指令让程序跳转到我们指定的位置执行，就需要修改原程序的执行流程。前面说到，在<code>00617A32</code>是执行删除的指令，<code>jmp</code>跳转指令共需要<code>5</code>个字节， <code>00617A32</code>所处的指令只有四个字节，不满足改写要求，<code>00617A32</code>前一条指令大于五个字节，因此在此处修改，修改如下：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E8%A1%A5%E4%B8%81%E4%BF%AE%E6%94%B9%E5%8E%9F%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4-16721233999171.png" alt="补丁修改原跳转指令"></p>
<p>　　<code>676F10</code> 处的补丁代码及注释如下：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E8%B7%B3%E8%BD%AC%E5%A4%84%E7%9A%84%E8%A1%A5%E4%B8%81%E4%BB%A3%E7%A0%81.png" alt="跳转处的补丁代码"></p>
<p>　　<code>00676F18</code>和<code>00676f1D</code>处的指令为判断字符是否为汉字，因为<code>0x7A</code>在<code>ASCII</code>中为小写的<code>“z”</code>，若小于<code>7A</code>,则删除一个字节，否则为汉字删除两个字节，将这两处修改到可执行文件并保存，替换原文件后成功修复该<code>bug</code>。文末附上修改前后效果：</p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E4%BF%AE%E6%94%B9%E5%89%8D.gif" alt="修改前"></p>
<p><img src="/2022/12/27/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%9F%90%E6%9C%8D%E8%81%8A%E5%A4%A9Bug/%E4%BF%AE%E6%94%B9%E5%90%8E.gif" alt="修改后"></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>thinkphp5.X全版本rce漏洞原理分析及复现</title>
    <url>/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="0x01-前言">0x01  前言</h2>
<p>  最近遇到的好多都是tp的洞，之前遇到的少，对原理、<code>payload</code>也没有深究过，看见tp就上工具，利用不了就下一个，毫不纠缠；但是近期发现有些存在<code>rce</code>的tp，工具也报，但是就是利用不了，网上找了好多<code>payload</code>都无效，遂萌生出了要究其原理的想法，毕竟网上铺天盖地的<code>payload</code>，参数又复杂，总不能瞎猫碰死耗子，本着探索求真的精神😑,在此分析记录。<span id="more"></span></p>
<h2 id="0x02-环境">0x02  环境</h2>
<p>  搭建tp环境一般有两种方法，一种是直接在github的tp项目中<code>clone</code>，另一种是用<code>composer</code>安装，安装完<code>composer</code>后使用<code>composer create-project topthink/think=5.0.7 tp5.0.7  --prefer-dist</code> 命令安装对应版本的tp框架，安装完毕后需要进入创建的目录下继续执行<code>composer install</code>来安装核心文件，这里使用该命令安装的理应是<code>5.0.7</code>版本的tp，但是安装的仍然是最新版本，说白了就是版本指定无效，懒得查找原因了，我所用的解决办法就是先利用上述命令安装，然后打开该目录下的<code>composer.json</code>文件，修改<code>&quot;topthink/framework&quot;: &quot;^5.0&quot;</code>为想安装的版本，然后删除同目录下的<code>composer.lock</code>，再执行<code>composer install</code>就会更新指定版本的框架并安装核心文件，这样环境才算搭好。需要注意的一个点是不仅要有tp的框架代码，还要有tp的核心代码，只安装框架代码就会出现如下错误：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230111150634229.png" alt="image-20230111150634229"></p>
<p>  该报错就是缺少了核心文件，也算是个小坑，记录一下。</p>
<p>  环境搭好之后，就正式开始<code>rce</code>的原理分析。网上搜索到的关于<code>rce</code>众多的<code>payload</code>，总结的话共有两种利用方式，从而衍生出了两种<code>payload</code>类型：</p>
<p>  <em><code>①  路由过滤不严谨导致rce。payload呈现如下格式：</code></em></p>
<p><em><code>/?s=/index/\think\app/invokefunction&amp;function=system&amp;vars[0]=whoami&amp;vars[1][]=-1</code></em></p>
<p>  <em><code>②  __construct变量覆盖导致rce。payload呈现如下格式：</code></em></p>
<p><em><code>_method=__construct&amp;filter=system&amp;a=whoami&amp;method=GET</code></em></p>
<h2 id="0x03-路由过滤不严导致rce">0x03  路由过滤不严导致rce</h2>
<p>  先分析第一个类型，此<code>payload</code>是利用兼容模式进行访问的（tp支持的url模式有四种），即<code>http://X.X.X.X/index.php?s=/模块/控制器/操作/[参数名/参数值...]</code>，按照上述给出的<code>payload</code>，对应关系即<code>index</code>为模块，<code>/think/app</code>为控制器，<code>invokefunction</code>为操作，<code>vars[0]</code>为参数名，<code>vars\[1][]</code>为参数值，那么<code>function</code>是哪来的？<code>s</code>参数路径中的&quot;\&quot;又具有什么意义？</p>
<p>  鉴于网上相关原理文章已经讲的很详细了，这里只挑重点的说。在<code>index.php</code>入口代码<code>run()  ---&gt; routeCheck() ---&gt;  path()  ---&gt;  pathinfo()</code>：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230111161229536.png" alt="image-20230111161229536"></p>
<p>  此方法会根据不同的url访问模式来获取当前URL的<code>pathinfo</code>信息，首先判断的是url中是否存在兼容模式参数，若存在会利用$_GET方法获取，若使用<code>pathinfo</code>模式，则会调用<code>$this-&gt;server(‘PATH_INFO’)</code>去获取，获取后调用<code>ltrim()</code>函数删除$pathinfo左侧的&quot;/&quot;符号,也就是说我们传入的s参数经过处理后变成了<code>index/\think\app/invokefunction</code>，紧接着会赋值给$path并带入check()方法对URL路由进行检测：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230111161548814.png" alt="image-20230111161548814"></p>
<p>  在该方法中，首先会将s参数中的&quot;/“符号替换为”|&quot;,s参数变为了<code>index|\\think\\app|invokefunction</code>。这里要说一下为什么必须是s参数才行，在tp的默认配置中，<code>var_pathinfo</code>在配置文件中被设置为s，所以我们可以用<code>$_GET[‘s’]</code>来传递路由信息：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112143543411.png" alt="image-20230112143543411"></p>
<p>  接下来会对路由地址，也就是s参数进行解析分割、验证、格式处理及赋值进而获取到相应的模块、控制器、操作名，在<code>parseUrl()</code>函数中：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230111162158195.png" alt="image-20230111162158195"></p>
<p>  该方法直接调用了<code>parseUrlPath()</code>函数：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230111162359485.png" alt="image-20230111162359485"></p>
<p><code>&amp;emsp;&amp;emsp;parseUrlPath()</code>会将修改过的s参数（<code>index|\\think\\app|invokefunction</code>）按照&quot;|&quot;进行分割，从而获取到对应的模块、控制器、操作、参数名、参数值。</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230111162722941.png" alt="image-20230111162722941"></p>
<p>  这里就解释了为什么s参数中要有&quot;\“符号(兼容模式<code>parseUrlPath()</code>函数没有对”\&quot;符号进行过滤，导致可以指定任意模块、控制器和方法)，s参数整体处理流程如下：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112205201508.png" alt="image-20230112205201508"></p>
<p>  那不加&quot;\&quot;可以吗？当然不可以，存在即合理，如果不加的话，就会解析成这样：</p>
<p>模块：<code>index</code>          控制器：<code>think</code>          操作：<code>app</code>          参数：<code>invokefunction</code></p>
<p>  这样解析肯定会出错，因为不存在think控制器，但如果加了<code>\</code>，<code>\think\app</code>就会当做一个整体去解析，<code>think</code>下的<code>app</code>控制器是存在的：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112100729160.png" alt="image-20230112100729160"></p>
<p>  随着代码继续执行来到另外一个关键点，<code>module</code>方法：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112205425199.png" alt="image-20230112205425199"></p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112102330278.png" alt="image-20230112102330278"></p>
<p>  该方法会获取路由中的模块、控制器、操作。</p>
<p>  在<code>module</code>方法的最后，会调用<code>invokeMethod()</code>函数再返回：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112102439804.png" alt="image-20230112102439804"></p>
<p>  在<code>invokeMethod()</code>函数中，首先会调用<code>bindParams()</code>函数，其作用是获取传入的参数并绑定参数：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112103650597.png" alt="image-20230112103650597"></p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112103523797.png" alt="image-20230112103523797"></p>
<p>  进行递归绑定的时候，php反射类规定需要<code>function</code>参数来确定所要调用的方法，方法的参数由<code>var</code>确定：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112105426646.png" alt="image-20230112105426646"></p>
<p>  这也解释了为什么一开始传入的s参数中要有<code>function</code>这个参数，如果将<code>function</code>改为其他名称，就会抛出<code>&quot;method param miss&quot;</code>异常：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112110150678.png" alt="image-20230112110150678"></p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112105920806.png" alt="image-20230112105920806"></p>
<p>  参数绑定完毕之后，会写入到<code>$args</code>变量中，最终调用<code>invokeargs</code>函数，该函数会调用指定的反射方法（<code>system</code>）并返回方法的结果，从而完成命令执行。</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112112057718.png" alt="image-20230112112057718"></p>
<p>  返回的结果保存在<code>$data</code>变量中：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112112500185.png" alt="image-20230112112500185"></p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112115438614.png" alt="image-20230112115438614"></p>
<h2 id="0x04-construct-变量覆盖导致rce">0x04  __construct 变量覆盖导致rce</h2>
<p>  这里还是挑重点的说。在<code>index.php</code>入口代码<code>run()---&gt; routeCheck() ---&gt;  method()</code>：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112142921991.png" alt="image-20230112142921991"></p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112144248162.png" alt="image-20230112144248162"></p>
<p>  此函数用于获取当前的请求类型，在该函数中，<code>$method = false</code>直接作为参数传入，会进入到elseif分支，在此分支中可以看到如下代码：<code>$this-&gt;&#123;$this-&gt;method&#125;($_POST)</code>，很明显，只要能控制<code>$this-&gt;method</code>的值就可以执行类中的任意函数，而<code>Config::get('var_method')</code>实际上获取的就是配置文件中<code>var_method</code>的值，为<code>\_method</code>：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112144937959.png" alt="image-20230112144937959"></p>
<p>  因此，payload中<code>_method=__construct</code>是为了调用<code>thinkphp/library/think/Request.php</code>下的<code>__construct</code>函数，但为什么选了__construct函数？在Requset.app的构造函数中下断，发现构造函数传入了post的参数，代码<code>$this-&gt;$name = $item</code>可以对变量进行赋值，这里就造成了变量覆盖漏洞，payload中的<code>filter=system和method=GET</code>分别将当前类下的<code>$filter</code>赋值成了<code>system</code>，<code>method</code>二次赋值由<code>__construct</code>变成了<code>GET</code>。</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112145426519.png" alt="image-20230112145426519"></p>
<p>  前面不是已经进行了<code>method</code>的赋值么，为什么又重新赋值？</p>
<p>  先说在<code>method()</code>函数执行完毕后，会执行<code>$rules = self::$rules[$method]</code>;来获取当前请求类型，而<code>$rules</code>做了如下约定：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112150523217.png" alt="image-20230112150523217"></p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112150635857.png" alt="image-20230112150635857"></p>
<p>  也就是说，规则之外的请求类型是不被允许的，如果不进行重新赋值，<code>$rules=__construct</code>， 程序会直接抛出异常：<img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112150909713.png" alt="image-20230112150909713"></p>
<p>  随着代码执行，又来到关键的一处，就是<code>module</code>方法，在前面第一个payload分析就说到<code>module</code>方法会获取路由中的模块、控制器、操作。最后，会调用<code>invokeMethod()</code>函数再返回，在<code>invokeMethod()</code>中，又有一个冤大头，就是<code>bindParams()</code>函数：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112151809272.png" alt="image-20230112151809272"></p>
<p>  在<code>bindParams()</code>函数中调用了<code>param()</code>函数：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112152006576.png" alt="image-20230112152006576"></p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112152035650.png" alt="image-20230112152035650"></p>
<p>  <code>param()</code>函数中又会调用<code>method()</code>函数获取当前请求类型，然后会根据请求的类型来获取参数并且合并参数，代码中可以看出，参数来源可以是<code>get[]</code>、<code>post</code>、<code>route[]</code>，那么我们传递<code>rce</code>的参数就有很多方式了：</p>
<p>①  a=whoami</p>
<p>②  bbbbb=whoami</p>
<p>③  get[]=whoami</p>
<p>④  route[]=whoami</p>
<p>  最后会调用<code>input()</code>函数并返回，<code>input</code>函数是一个过滤函数，会对我们输入的数据进行过滤，函数结尾有一个<code>filterValue()</code>函数，是触发rce的核心点：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112152718903.png" alt="image-20230112152718903"></p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112153022482.png" alt="image-20230112153022482"></p>
<p>  <code>call_user_func</code>不用多说了吧，代码执行函数，还记得前面为什么将<code>filter</code>通过变量覆盖变成了<code>system</code>吗？就是为了通过<code>call_user_func</code>来调用它，再加上传入的参数，成功执行<code>system(whoami)</code>，完成整个rce过程。</p>
<p>  至此，变量覆盖的<code>rce</code>也分析完了。</p>
<hr>
<p>  是不是以为结束了，不，还没有😇（看累了吧，我也写累了😭）。</p>
<p>  变量覆盖的<code>payload</code>到<code>5.0.13</code>之前都是可以成功的，从<code>5.0.13</code>之后，代码有了改动，rce的必经之路module方法<code>（thinkphp/library/think/App.php）</code>中多了这样一行代码：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112155251267.png" alt="image-20230112155251267"></p>
<p>  直接将我们提前覆盖好的<code>filter</code>变量又覆盖成默认的了，这样，覆盖<code>filter</code>的这条路已经行不通了。</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112160709111.png" alt="image-20230112160709111"></p>
<p>  tp有没有开启<code>app_debug</code>很重要，如果开启了<code>app_debug</code>，会执行这几行代码：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112155917746.png" alt="image-20230112155917746"></p>
<p>  如果已经看懂了前面的原理，一眼就能看出，开启了<code>app_debug</code>又会执行<code>param()</code>函数，而<code>param()</code>函数又会走前面分析的老路，<code>param()  ---&gt;  input()  ---&gt;  filterValue  ---&gt;  call_user_func()</code>，最终仍然可以rce：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112161536866.png" alt="image-20230112161536866"></p>
<p>  这里就出现了一个小细节，在<code>5.0.13</code>之前执行payload有时候返回一条结果，有时候返回两条，究其原理就是在利用变量覆盖漏洞rce的时候，由于<code>app_debug</code>和正常代码逻辑都会调用<code>param()</code>函数，因此若开启了<code>app_debug</code>，会执行两次命令，返回两条结果，未开启则返回一条：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112162850991.png" alt="image-20230112162850991"></p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112162854740.png" alt="image-20230112162854740"></p>
<p>  最后再提一下另一种payload方法：<code>/?s=captcha</code>，这种是利用验证码类库进行攻击的，<code>captcha</code>的路由在<code>vendor/topthink/think-captcha/src/helper.php</code>进行了定义：</p>
<p><code>\think\Route::get('captcha/[:id]', &quot;\\think\\captcha\\CaptchaController@index&quot;);</code></p>
<p>  而<code>captcha</code>路由对应的dispatch类型为<code>method</code>，即代码流程不会执行module这条分支，转而会执行<code>method</code>所在的分支，完美的避开了在<code>5.0.13</code>中module()函数<code>filter</code>变量被二次覆盖导致攻击链中断的问题，也就是说，<code>5.0.13</code>之后的版本若没有开启<code>app_debug</code>，还可以利用第三方类库如<code>captcha</code>进行攻击（疲于安装，就不演示了😅）：</p>
<p><img src="/2023/01/11/thinkphp5.X%E5%85%A8%E7%89%88%E6%9C%ACrce%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0/image-20230112164202753.png" alt="image-20230112164202753"></p>
<h2 id="0x05-总结">0x05  总结</h2>
<p>  其实前面提到的<code>payload</code>也仅仅只是一种，明白了原理，只要类里面存在<code>call_user_func()</code>都可以想办法构造payload进行攻击，又由于接收参数的多样、参数名的多样、还可以利用文件包含、文件读写函数写shell等因素，造就了铺天盖地的payload。变量覆盖漏洞在<code>5.1.X</code>的低版本也可以利用，只不过需要开启<code>app_debug</code>或者利用第三方库才能成功。 测试下来，<code>5.1.5</code>之后的版本就失效了（<code>5.1.X</code>仅测试了开启<code>app_debug</code>的结果，未测试第三方类库的利用），而<code>5.0.X</code>版本的利用从<code>5.0.24</code>开始彻底被修复。</p>
<p>  最终总结如下：</p>
<p>  <em><code>① 5.0.0-5.0.12——可无条件rce， construct变量覆盖和控制路由参数这两种方法均可。</code></em></p>
<p>  <em><code>② 5.0.13-5.0.23——可使用construct变量覆盖的payload（参数限定为get[]或route[]），但需开启app_debug或使用第三方类库。</code></em></p>
<p>  <em><code>③ 5.1.1-5.1.5——可使用construct变量覆盖的payload（参数限定为get[]或route[]），但需开启app_debug或使用第三方类库。</code></em></p>
<hr>
<p>                    💐  完结撒花！💐</p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
</search>
